let { Value } = import! std.serialization.types
let prim = import! std.serialization.prim

let { Result, ? } = import! std.result
let std_map@{ Map, ? } = import! std.map
let { id } = import! std.function
let float = import! std.float

let { map } = import! std.functor
let { (*>), (<*), wrap } = import! std.applicative
let { Alternative, (<|>) } = import! std.applicative
let { flat_map } = import! std.monad
let { for } = import! std.traversable
let { ? } = import! std.array


type Error = String
type Deserializer i a = i -> Result Error { value : a, input : i }

type ValueDeserializer a = Deserializer Value a

let error_msg = id

let deserializer : Deserializer i a -> Deserializer i a = id

let functor : Functor (Deserializer i) = {
    map = \f m -> deserializer (\input ->
            do a = deserializer m input
            Ok { value = f a.value, input = a.input })
}

let applicative : Applicative (Deserializer i) = {
    functor,

    apply = \f m -> deserializer (\input ->
            do g = deserializer f input
            do a = deserializer m g.input
            Ok { value = g.value a.value, input = a.input }),

    wrap = \value -> deserializer (\input -> Ok { value, input }),
}

let alternative : Alternative (Deserializer i) = {
    applicative,

    or = \l r -> deserializer (\stream ->
            match deserializer l stream with
            | Ok a -> Ok a
            | Err _ -> deserializer r stream),
    empty = deserializer (\stream -> Err (error_msg "empty")),
}

let monad : Monad (Deserializer i) = {
    applicative,

    flat_map = \f m ->
        deserializer (\input ->
                do a = deserializer m input
                deserializer (f a.value) a.input
            ),
}

///
/// ```
/// let { Value, bool, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { assert } = import! std.test
///
/// assert (deserialize bool "true" == Ok True)
/// assert (deserialize bool "123" == Err "Expected bool")
/// ```
let bool : ValueDeserializer Bool = \input ->
    match input with
    | Bool i -> Ok { value = i, input }
    | _ -> Err (error_msg "Expected bool")

///
/// ```
/// let { Value, float, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { assert } = import! std.test
///
/// assert (deserialize float "123.45" == Ok 123.45)
/// assert (deserialize float "123" == Ok 123.0)
/// assert (deserialize float "true" == Err "Expected float")
/// ```
let float : ValueDeserializer Float = \input ->
    match input with
    | Int i -> Ok { value = float.from_int i, input }
    | Float f -> Ok { value = f, input }
    | _ -> Err (error_msg "Expected float")

///
/// ```
/// let { Value, int, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { assert } = import! std.test
///
/// assert (deserialize int "123" == Ok 123)
/// assert (deserialize int "true" == Err "Expected integer")
/// ```
let int : ValueDeserializer Int = \input ->
    match input with
    | Int i -> Ok { value = i, input }
    | _ -> Err (error_msg "Expected integer")

///
/// ```
/// let { Value, string, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { assert } = import! std.test
///
/// assert (deserialize string "\"abc\"" == Ok "abc")
/// assert (deserialize string "true" == Err "Expected string")
/// ```
let string : ValueDeserializer String = \input ->
    match input with
    | String s -> Ok { value = s, input }
    | _ -> Err (error_msg "Expected string")

///
/// ```
/// let { Value, array, int, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { ? } = import! std.array
/// let { assert } = import! std.test
///
/// assert (deserialize (array int) "[123, 456]" == Ok [123, 456])
/// assert (deserialize (array int) "[123, \"\"]" == Err "Expected integer")
/// ```
let array a : ValueDeserializer a -> ValueDeserializer (Array a) = \input ->
    match input with
    | Array xs ->
        do value = for xs (\v ->
            do state = a v
            Ok state.value)
        Ok { value, input }
    | _ -> Err (error_msg "Expected array")

///
/// ```
/// let { Value, option, int, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { ? } = import! std.array
/// let { assert } = import! std.test
///
/// assert (deserialize (option int) "123" == Ok (Some 123))
/// assert (deserialize (option int) "null" == Ok None)
/// assert (deserialize (option int) "\"\"" == Err "Expected integer")
/// ```
let option a : ValueDeserializer a -> ValueDeserializer (Option a) = \input ->
    match input with
    | Null -> Ok { value = None, input }
    | _ -> (map Some a) input

///
/// ```
/// let { Value, field, int, deserialize } = import! std.serialization.de
/// let { Result, ? } = import! std.result
/// let { ? } = import! std.array
/// let { assert } = import! std.test
///
/// assert (deserialize (field "test" int) "{ \"test\": 123 }" == Ok 123)
/// assert (deserialize (field "test" int) "{ \"abc\": 123 }" == Err "Expected field `test`")
/// ```
let field name a : String -> ValueDeserializer a -> ValueDeserializer a = \input ->
    match input with
    | Object o ->
        match std_map.find name o with
        | Some value ->
            do state = a value
            Ok { value = state.value, input }
        | None -> Err (error_msg ("Expected field `" ++ name ++ "`"))
    | _ -> Err (error_msg "Expected map") 
let deserialize de input : ValueDeserializer a -> String -> Result Error a =
    do value = prim.deserialize input
    do state = de value
    Ok state.value

let run de value : ValueDeserializer a -> Value -> Result Error a =
    do state = de value
    Ok state.value

#[doc(hidden)]
let insert_string : String -> a -> Map String a -> Map String a = std_map.insert

#[implicit]
type Deserialize a = { deserializer : ValueDeserializer a  }

let deserializer ?d : [Deserialize a] -> ValueDeserializer a = d.deserializer

let int_deserializer : Deserialize Int = { deserializer = int }
let float_deserializer : Deserialize Float = { deserializer = float }
let string_deserializer : Deserialize String = { deserializer = string }

{
    Value,
    Error,
    Deserializer,
    ValueDeserializer,
    Deserialize,

    functor,
    applicative,
    alternative,
    monad,

    bool,
    int,
    float,
    string,
    array,
    field,
    option,

    deserialize,
    run,

    deserializer,

    int_deserializer,
    string_deserializer,
    float_deserializer,

    insert_string
}
