//@NO-IMPLICIT-PRELUDE
//! Functionality for ordering and comparison.

let { Bool, Ordering } = import! std.types
let { Semigroup } = import! std.semigroup
let { Monoid } = import! std.monoid

/// `Eq a` defines equality (==) on `a`
#[implicit]
type Eq a = { (==) : a -> a -> Bool }

#[infix(left, 4)]
let (==) ?eq : [Eq a] -> a -> a -> Bool = eq.(==)
#[infix(left, 4)]
let (/=) ?eq l r : [Eq a] -> a -> a -> Bool = if (eq.(==) l r) then False else True

/// `Ord a` defines an ordering on `a`
#[implicit]
type Ord a = { eq : Eq a, compare : a -> a -> Ordering }

let compare ?ord : [Ord a] -> a -> a -> Ordering = ord.compare

#[infix(left, 4)]
let (<=) l r : [Ord a] -> a -> a -> Bool =
    match compare l r with
    | LT -> True
    | EQ -> True
    | GT -> False

#[infix(left, 4)]
let (<) l r : [Ord a] -> a -> a -> Bool =
    match compare l r with
    | LT -> True
    | EQ -> False
    | GT -> False

#[infix(left, 4)]
let (>) l r : [Ord a] -> a -> a -> Bool =
    match compare l r with
    | LT -> False
    | EQ -> False
    | GT -> True

#[infix(left, 4)]
let (>=) l r : [Ord a] -> a -> a -> Bool =
    match compare l r with
    | LT -> False
    | EQ -> True
    | GT -> True


let semigroup : Semigroup Ordering = {
    append = \x y ->
        match x with
        | EQ -> y
        | _ -> x,
}

let monoid : Monoid Ordering = {
    semigroup,
    empty = EQ,
}

{
    Eq,
    (==), (/=),

    Bool,

    Ord,
    compare, (<), (<=), (>=), (>),

    Ordering,

    semigroup,

    monoid,
}
