let prelude = import! "std/prelude.glu"
let { Functor, Applicative, Alternative, Monad } = prelude
let { (<<), id } = prelude.make_Category prelude.category_Function
let { pure } = prelude.applicative_IO

/// HTTP method
type Method = | Get | Post | Delete | Update

/// Type used by handlers to indicate why they could not process a request
type Failure = | DontProcess

/// HTTP server request
type Request = { method: Method }

/// HTTP server response
type Response = { body: String }

/// The main type of this micro http framework. A handler takes two continuations and a `Request` and
/// cakks one of the continuations depending on if it can successfully handle the request or not
type Handler a =
    // Success continuation
    (a -> Request -> IO Response) ->
    // Failure continuation
    (Failure -> Request -> IO Response) ->
    Request ->
    IO Response

/// Force the value to be a Handler. Used to make the the type inference work for higher-kinded types
let make: Handler a -> Handler a = id

let functor: Functor Handler = {
    map = \f handler ->
        // FIXME type inference fails without this
        let handler = make handler
        make (\success failure request -> handler (success << f) failure request)
}

let flat_map f handler: (a -> Handler b) -> Handler a -> Handler b =
    // FIXME type inference fails without this
    let handler = make handler
    make (\success failure request ->
        let success2 a r = make (f a) success failure request
        handler success2 failure request)


let applicative: Applicative Handler = {
    functor,
    apply = \a m ->
        let m = make m
        flat_map (\f -> functor.map f m) a,
    pure = \a -> make (\success _ request -> success a request)
}
let { (*>) } = prelude.make_Applicative applicative

let alternative: Alternative Handler = {
    applicative,
    // Tries to handle the request with `l`, if it fails with `DontProcess` then `r` is tried instead
    or = \l r -> make (\success failure request ->
        let failure2 reason request2 =
            match reason with
            | DontProcess -> make r success failure request2

        make l success failure2 request),
    empty = make (\_ failure request -> failure DontProcess request)
}
let { or, empty, (<|>) } = prelude.make_Alternative alternative

let monad: Monad Handler = {
    applicative,
    flat_map
}

/// Handles the request if `predicate` returns `True
let test predicate: (Request -> Bool) -> Handler () =
    \success failure request ->
        if predicate request then
            success () request
        else
            failure DontProcess request

/// Handles `Get` requests
let get handler: Handler a -> Handler a =
    test (\request ->
        match request.method with
        | Get -> True
        | _ -> False) *> handler

/// Handles `Post` requests
let post handler: Handler a -> Handler a =
    test (\request ->
        match request.method with
        | Post -> True
        | _ -> False) *> handler

/// Retrieves the HTTP request
let get_request : Handler Request =
    \success _ request -> success request request

/// Takes a `Handler` and a `Request` tries to process the request
let handle handler request : Handler Response -> Request -> IO Response =
    let not_found _ _ =
        pure { body = "404" }
    handler (\response _ -> pure response) not_found request 

{
    Method,
    Failure,
    Request,
    Response,
    Handler,

    functor,
    applicative,
    monad,

    get_request,
    handle,
    get,
    post
}
